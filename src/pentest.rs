use crate::AptosBB;
use anyhow::Result;
use aptos_types::{
    account_address::AccountAddress,
};
use move_core_types::{
    identifier::Identifier,
    language_storage::{StructTag, TypeTag},
    move_resource::MoveStructType,
};
use aptos_types::account_config::{fungible_store::FungibleStoreResource, ObjectGroupResource};    
use std::str::FromStr;
use std::path::Path;

/// Main pentesting function - called by AptosBB with live mainnet state
/// Edit this function to write your custom tests against live contracts
pub fn run_pentest(mut bb: AptosBB) -> Result<()> {
    
    println!("üéØ AptosBB Pentesting Framework");
    println!("Connected to live mainnet state for testing\n");
    
    // Example step1: Create an attacker account
    let attacker = bb.new_account();
    println!("Attacker address: {}", attacker.address());
    
    // Show detailed account information
    println!("Account details:");
    if let Some(account_resource) = bb.read_account_resource_at_address(&attacker.address()) {
        println!("   Sequence number: {}", account_resource.sequence_number());
        println!("   Authentication key: {:?}", account_resource.authentication_key());
    }
    
    // Check APT balance
    if bb.has_apt_balance(&attacker) {
        if let Some(balance) = bb.read_apt_fungible_store_resource(&attacker) {
            println!("   APT balance: {} (= {} APT)", balance, balance / 100_000_000);
        }
    } else {
        println!("‚ùå APT balance not found - account may not be funded");
    }
    println!();
    
    // Example step2: Deploy custom local module for testing
    // Update the Move.toml with the attacker's address
    let move_toml_path = Path::new("./module/Move.toml");
    let move_toml_content = std::fs::read_to_string(move_toml_path)
        .expect("Failed to read Move.toml");
    
    // Replace the hello_world address with the attacker's address
    let updated_toml = move_toml_content
        .lines()
        .map(|line| {
            if line.starts_with("hello_world = ") {
                format!("hello_world = \"{}\"", attacker.address())
            } else {
                line.to_string()
            }
        })
        .collect::<Vec<_>>()
        .join("\n");
    
    std::fs::write(move_toml_path, updated_toml)
        .expect("Failed to write updated Move.toml");
    println!("Updated Move.toml with attacker address: {}", attacker.address());
    
    let hello_world_path = Path::new("./module");
    let status = bb.publish_package(&attacker, hello_world_path);
    println!("Deploy status: {:?}\n", status);
    
    // Call initialize function
    println!("Calling initialize function...");
    let hello_world_addr = *attacker.address();
    let init_status = bb.run_entry_function(
        &attacker,
        hello_world_addr,
        "hello_world",
        "initialize",
        vec![],
        vec![],
    );
    println!("Initialize status: {:?}\n", init_status);
    
    // Call say_hello function
    for i in 1..=3 {
        println!("  Call say_hello attempt {}:", i);
        let hello_status = bb.run_entry_function(
            &attacker,
            hello_world_addr,
            "hello_world",
            "say_hello",
            vec![],
            vec![],
        );
        println!("  Status: {:?}", hello_status);
    }
    println!();
    
    // Example step3: Check resource GreetingCounter
    let greeting_counter_tag = StructTag {
        address: hello_world_addr,
        module: Identifier::new("hello_world").unwrap(),
        name: Identifier::new("GreetingCounter").unwrap(),
        type_args: vec![],
    };
    
    if bb.exists_resource(&attacker.address(), greeting_counter_tag.clone()) {
        println!("‚úÖ GreetingCounter resource found at attacker address!");
        
        #[derive(Debug, serde::Deserialize)]
        struct GreetingCounter {
            count: u64,
        }
        
        // Try to read the raw state value and deserialize it
        use aptos_types::state_store::state_key::StateKey;
        if let Ok(state_key) = StateKey::resource(&attacker.address(), &greeting_counter_tag) {
            if let Some(state_value) = bb.read_state_value(&state_key) {
                if let Ok(greeting_counter) = bcs::from_bytes::<GreetingCounter>(&state_value.into_bytes()) {
                    println!("   Greeting count: {}", greeting_counter.count);
                    println!("   Full resource: {:?}", greeting_counter);
                } else {
                    println!("   ‚ö†Ô∏è Could not deserialize GreetingCounter resource");
                }
            } else {
                println!("   ‚ö†Ô∏è Could not read state value for GreetingCounter");
            }
        } else {
            println!("   ‚ö†Ô∏è Could not create state key for GreetingCounter");
        }
    } else {
        println!("‚ùå GreetingCounter resource not found");
    }
    println!();
    
    // Example step4: Call lending::set_paused function from the Echelon Market
    // https://explorer.aptoslabs.com/account/0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba/modules/code/lending?network=mainnet
    // let lending_addr = AccountAddress::from_hex_literal("0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba").unwrap();
    
    // Try to pause the lending protocol (set to true)
    // let pause_args = vec![bcs::to_bytes(&true).unwrap()];
    // let pause_status = bb.run_entry_function(
    //     &attacker,
    //     lending_addr,
    //     "lending",
    //     "set_paused",
    //     vec![], // no type args
    //     pause_args,
    // );
    // println!("set_paused(true) status: {:?}", pause_status); // it should fail because we don't have permission to call
    // println!();
    
    // Example step5: Call swap_exact_in from Thala's stable_pool_scripts
    let thala_addr = AccountAddress::from_hex_literal("0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af").unwrap();
    
    // StablePool<AptosCoin, ShrimpCoin, Null, Null>
    let type_args = vec![
        TypeTag::from_str("0x1::aptos_coin::AptosCoin").unwrap(), // Asset0: APT
        TypeTag::from_str("0x55987edfab9a57f69bac759674f139ae473b5e09a9283848c1f87faf6fc1e789::shrimp::ShrimpCoin").unwrap(), // Asset1: ShrimpCoin
        TypeTag::from_str("0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null").unwrap(), // Asset2: Null
        TypeTag::from_str("0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af::base_pool::Null").unwrap(), // Asset3: Null
        TypeTag::from_str("0x1::aptos_coin::AptosCoin").unwrap(),
        TypeTag::from_str("0x55987edfab9a57f69bac759674f139ae473b5e09a9283848c1f87faf6fc1e789::shrimp::ShrimpCoin").unwrap(),
    ];
    
    // Swap parameters
    let amount_in: u64 = 100000; // 0.001 APT (8 decimals)
    let min_amount_out: u64 = 0; // Accept any amount out for testing
    
    let swap_args = vec![
        bcs::to_bytes(&amount_in).unwrap(),
        bcs::to_bytes(&min_amount_out).unwrap(),
    ];
    
    println!("Pool configuration: APT/SHRIMP/Null/Null");
    
    let entry_fn = aptos_types::transaction::EntryFunction::new(
        move_core_types::language_storage::ModuleId::new(
            thala_addr,
            Identifier::new("stable_pool_scripts").unwrap()
        ),
        Identifier::new("swap_exact_in").unwrap(),
        type_args,
        swap_args,
    );
    
    let (swap_status, swap_output) = bb.run_transaction_with_output(&attacker, aptos_types::transaction::TransactionPayload::EntryFunction(entry_fn));
    println!("swap_exact_in status: {:?}", swap_status);
    
    // Display transaction details
    println!("\nTransaction Details:");
    println!("  Gas used: {}", swap_output.gas_used());
    println!("  Events emitted: {}", swap_output.events().len());
    
    // Display transaction events
    for (i, event) in swap_output.events().iter().enumerate() {
        println!("  Event {}: Type: {:?}", i, event.type_tag());
        println!("    Data (first 100 bytes): {:?}", &event.event_data()[..event.event_data().len().min(100)]);
    }
    
    if swap_status == aptos_types::transaction::TransactionStatus::Keep(aptos_types::transaction::ExecutionStatus::Success) {
        println!("\nSwap succeeded!");
    } else {
        println!("\nSwap failed!");
    }
    
    let mut shrimp_balance: Option<u64> = None;
    let write_set_debug = format!("{:?}", swap_output.write_set());
    let metadata_hex = "d4c0be6af89a42d78fb728dd57096eda717d7044c2dd635a01417662c33614fc";
    let balance_hex = "6b0300000000000000"; // 875 in little endian hex
    
    for entry in write_set_debug.split("StateKey::AccessPath") {
        if entry.contains("Creation(") && entry.contains(metadata_hex) && entry.contains(balance_hex) {
            if let Some(start) = entry.find("{ address: 0x") {
                let addr_start = start + 13; 
                if let Some(end) = entry[addr_start..].find(',') {
                    let addr_hex = &entry[addr_start..addr_start + end];
                    if let Ok(addr) = AccountAddress::from_hex_literal(&format!("0x{}", addr_hex)) {
                        println!("Found ShrimpCoin FungibleStore address from WriteSet: {}", addr);
                        
                        // Read the Store
                        if let Some(store) = bb.executor.read_resource_from_group::<FungibleStoreResource>(&addr, &ObjectGroupResource::struct_tag()) {
                            println!("Confirmed FungibleStore at: {}", addr);
                            println!("   Balance: {} ShrimpCoin", store.balance());
                            shrimp_balance = Some(store.balance());
                            break;
                        }
                    }
                }
            }
        }
    }
    
    // Final check
    match shrimp_balance {
        Some(0) => {
            println!("ShrimpCoin store exists but balance is 0");
        },
        Some(balance) => {
            println!("ShrimpCoin Balance: {}!", balance);
        },
        None => {
            println!("No ShrimpCoin FungibleStore found.");
        }
    }
    
    Ok(())
}
use crate::AptosBB;
use anyhow::Result;
use aptos_types::{
    account_address::AccountAddress,
    transaction::TransactionPayload,
};
use move_core_types::{
    identifier::Identifier,
    language_storage::{ModuleId, StructTag, TypeTag},
    value::MoveValue,
};
use std::path::Path;

/// Main pentesting function - called by AptosBB with live mainnet state
/// Edit this function to write your custom tests against live contracts
pub fn run_pentest(mut bb: AptosBB) -> Result<()> {
    
    println!("üéØ AptosBB Pentesting Framework");
    println!("Connected to live mainnet state for testing\n");
    
    // Example step1: Create an attacker account
    let attacker = bb.new_account();
    println!("Attacker address: {}", attacker.address());
    
    // Show detailed account information
    println!("Account details:");
    if let Some(account_resource) = bb.read_account_resource_at_address(&attacker.address()) {
        println!("   Sequence number: {}", account_resource.sequence_number());
        println!("   Authentication key: {:?}", account_resource.authentication_key());
    }
    
    // Check APT balance
    if bb.has_apt_balance(&attacker) {
        if let Some(balance) = bb.read_apt_fungible_store_resource(&attacker) {
            println!("   APT balance: {} (= {} APT)", balance, balance / 100_000_000);
        }
    } else {
        println!("‚ùå APT balance not found - account may not be funded");
    }
    println!();
    
    // Example step2: Deploy custom local module for testing
    // Update the Move.toml with the attacker's address
    let move_toml_path = Path::new("./module/Move.toml");
    let move_toml_content = std::fs::read_to_string(move_toml_path)
        .expect("Failed to read Move.toml");
    
    // Replace the hello_world address with the attacker's address
    let updated_toml = move_toml_content
        .lines()
        .map(|line| {
            if line.starts_with("hello_world = ") {
                format!("hello_world = \"{}\"", attacker.address())
            } else {
                line.to_string()
            }
        })
        .collect::<Vec<_>>()
        .join("\n");
    
    std::fs::write(move_toml_path, updated_toml)
        .expect("Failed to write updated Move.toml");
    println!("Updated Move.toml with attacker address: {}", attacker.address());
    
    let hello_world_path = Path::new("./module");
    let status = bb.publish_package(&attacker, hello_world_path);
    println!("Deploy status: {:?}\n", status);
    
    // Call initialize function
    println!("Calling initialize function...");
    let hello_world_addr = *attacker.address();
    let init_status = bb.run_entry_function(
        &attacker,
        hello_world_addr,
        "hello_world",
        "initialize",
        vec![],
        vec![],
    );
    println!("Initialize status: {:?}\n", init_status);
    
    // Call say_hello function
    for i in 1..=3 {
        println!("  Call say_hello attempt {}:", i);
        let hello_status = bb.run_entry_function(
            &attacker,
            hello_world_addr,
            "hello_world",
            "say_hello",
            vec![],
            vec![],
        );
        println!("  Status: {:?}", hello_status);
    }
    println!();
    
    // Example step3: Check resource GreetingCounter
    let greeting_counter_tag = StructTag {
        address: hello_world_addr,
        module: Identifier::new("hello_world").unwrap(),
        name: Identifier::new("GreetingCounter").unwrap(),
        type_args: vec![],
    };
    
    if bb.exists_resource(&attacker.address(), greeting_counter_tag.clone()) {
        println!("‚úÖ GreetingCounter resource found at attacker address!");
        
        #[derive(Debug, serde::Deserialize)]
        struct GreetingCounter {
            count: u64,
        }
        
        // Try to read the raw state value and deserialize it
        use aptos_types::state_store::state_key::StateKey;
        if let Ok(state_key) = StateKey::resource(&attacker.address(), &greeting_counter_tag) {
            if let Some(state_value) = bb.read_state_value(&state_key) {
                if let Ok(greeting_counter) = bcs::from_bytes::<GreetingCounter>(&state_value.into_bytes()) {
                    println!("   Greeting count: {}", greeting_counter.count);
                    println!("   Full resource: {:?}", greeting_counter);
                } else {
                    println!("   ‚ö†Ô∏è Could not deserialize GreetingCounter resource");
                }
            } else {
                println!("   ‚ö†Ô∏è Could not read state value for GreetingCounter");
            }
        } else {
            println!("   ‚ö†Ô∏è Could not create state key for GreetingCounter");
        }
    } else {
        println!("‚ùå GreetingCounter resource not found");
    }
    println!();
    
    // Example step4: Call lending::set_paused function from the Echelon Market
    // https://explorer.aptoslabs.com/account/0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba/modules/code/lending?network=mainnet
    let lending_addr = AccountAddress::from_hex_literal("0xc6bc659f1649553c1a3fa05d9727433dc03843baac29473c817d06d39e7621ba").unwrap();
    
    // Try to pause the lending protocol (set to true)
    let pause_args = vec![bcs::to_bytes(&true).unwrap()];
    let pause_status = bb.run_entry_function(
        &attacker,
        lending_addr,
        "lending",
        "set_paused",
        vec![], // no type args
        pause_args,
    );
    println!("set_paused(true) status: {:?}", pause_status); // it should fail because we don't have permission to call
    
    
    Ok(())
}